# Introduction
     __This report is a final submission of 5-day workshop from VLSI Sytem Design-IAT on RTL design and synthesis using open source tools,in particular iVerilog, GTKWave, Yosy and Skywater 130nm Standard Cell Libraries
     
## Introduction to RTLDesignandSynthesis
RTLDesign:Register transfer level is a mode of transfer of logic from register to register.RTLDesign can be one code orr set of codes that contain multiple modules for the realisation of logic 
Testbench:Testbench is the setup to apply stimulus test vectors to know how to check it Test bench does'nt have primary input or primary output<img width="763" alt="Screen Shot 2022-05-01 at 21 44 00" src="https://user-images.githubusercontent.com/104512677/166154676-5a0978be-00e3-4196-a5c9-a578a1551206.png">
Simulator:simulator works based on the change in input the output is evaluated .no change in input there will be no change in output.here is the flow of front end design 
<img width="800" alt="Screen Shot 2022-05-01 at 21 46 39" src="https://user-images.githubusercontent.com/104512677/166154789-bb8de989-e6a7-46f2-b3aa-8081ddca0f35.png">

gtkwavelab1:In this lab we are working on linux operating system by cloning the files from github using comman git clone
<img width="1440" alt="Screen Shot 2022-04-29 at 16 06 17" src="https://user-images.githubusercontent.com/104512677/166154933-133d368d-f97e-4cbc-a4fb-83edb7163a79.png">
<img width="1440" alt="Screen Shot 2022-04-29 at 16 08 38" src="https://user-images.githubusercontent.com/104512677/166155034-10aac897-add4-4389-a970-98fb14ad1032.png">

lab2:Introduction to iverilog and gtkwave In this lab simulation of multiplexer is done and VCD(Value Change Dump) file is generated by adding both verilog code and testbench to iverilog in the gtkwave waveforms are generated by using inputs in the testbench 
<img width="1440" alt="Screen Shot 2022-04-29 at 16 13 38" src="https://user-images.githubusercontent.com/104512677/166155491-c6ef3d2d-389f-40be-bb97-ac0e2f886d2f.png">


verilog code and testbench for multiplexer

```
module good_mux (input i0 , input i1 , input sel , output reg y);
always @ (*)
begin
if(sel)
y <= i1;
else
y <= i0;
end
endmodule```

```timescale 1ns / 1ps
module tb_good_mux;
// Inputs
reg i0,i1,sel;
// Outputs
wire y;
// Instantiate the Unit Under Test (UUT), name based instantiation
good_mux uut (.sel(sel),.i0(i0),.i1(i1),.y(y));
//good_mux uut (sel,i0,i1,y); //order based instantiation
initial begin
$dumpfile("tb_good_mux.vcd");
$dumpvars(0,tb_good_mux);
// Initialize Inputs
sel = 0;
i0 = 0;
i1 = 0;
#300 $finish;
end
always #75 sel = ~sel;
always #10 i0 = ~i0;
always #55 i1 = ~i1;
endmodule```
```
<img width="1440" alt="Screen Shot 2022-04-29 at 16 21 20" src="https://user-images.githubusercontent.com/104512677/166157488-ab8315cb-6c57-4e54-a552-304558db4698.png">

Introduction to yosys:an overview of the operation of the tool and the files we'll need to provide the tool to give the required netlist. We give RTL design code, .lib file which has all the building blocks of the netlist. Using these two files, Yosys synthesizer generates a netlist file. .lib basically is a collection of logical modules like, And, Or, Not etc.... These are equivalent gate level representation of the RTL code. Below are the commands to perform above synthesis.
<img width="1440" alt="Screen Shot 2022-04-29 at 17 10 02" src="https://user-images.githubusercontent.com/104512677/166158717-41b83aad-6e3a-4ce7-84e0-cce1847813ed.png">
<img width="1440" alt="Screen Shot 2022-05-01 at 14 14 42" src="https://user-images.githubusercontent.com/104512677/166158904-43e03a4e-b8a1-4dc5-8273-c9396ea12720.png">
<img width="1440" alt="Screen Shot 2022-05-01 at 14 24 32" src="https://user-images.githubusercontent.com/104512677/166158915-5707de56-3176-4459-b14e-251ef20e5d74.png">

##DAY2-Timing libs, hierarchical vs flat synthesis and efficient flop coding styles Introduction to timing .libs LAB4-SKY130RTL D2SK1 L1 Lab4 Introduction to dot Lib
This lab guides us through the .lib files where we have all the gates coded in. 
Command to open the sky130_fd_sc_hd__tt_025C_1v80.lib file:
**~/sky130RTLDesignAndSynthesisWorkshop/verilog_files$ gvim ../my_lib/lib/sky130_fd_sc_hd__tt_025C_1v80.lib**
<img width="1440" alt="Screen Shot 2022-05-01 at 15 06 15" src="https://user-images.githubusercontent.com/104512677/166159105-819257a5-2dbc-4d3c-82c8-daec30700921.png">
COMPARISION OF AND GATES FOR 2_0 2_1 2_4 AS THE CELL SIZE IS INCREASING  CELL AREA IS ALSO INCREASING HERE IS THE SNIPPET OF COMPARISION 
<img width="1440" alt="Screen Shot 2022-05-01 at 17 07 06" src="https://user-images.githubusercontent.com/104512677/166159139-cd15ef5b-0e96-4651-bbc2-800bc46761f9.png">
**LAB-5-SKY130RTL D2SK2 L1 Lab05 Hier synthesis flat synthesis part1**
Here in this lab we are synthesizing the netlist in to a simple one for the verilog code multiple_modules.v
```
module sub_module2 (input a, input b, output y);
	assign y = a | b;
endmodule

module sub_module1 (input a, input b, output y);
	assign y = a&b;
endmodule


module multiple_modules (input a, input b, input c , output y);
	wire net1;
	sub_module1 u1(.a(a),.b(b),.y(net1));  //net1 = a&b
	sub_module2 u2(.a(net1),.b(c),.y(y));  //y = net1|c ,ie y = a&b + c;
endmodule
```
after flattening we get netlist as shown below
```
module multiple_modules(a, b, c, y);
  wire _0_;
  wire _1_;
  wire _2_;
  wire _3_;
  wire _4_;
  wire _5_;
  input a;
  input b;
  input c;
  wire net1;
  wire \u1.a ;
  wire \u1.b ;
  wire \u1.y ;
  wire \u2.a ;
  wire \u2.b ;
  wire \u2.y ;
  output y;
  sky130_fd_sc_hd__and2_0 _6_ (
    .A(_1_),
    .B(_0_),
    .X(_2_)
  );
  sky130_fd_sc_hd__lpflow_inputiso1p_1 _7_ (
    .A(_4_),
    .SLEEP(_3_),
    .X(_5_)
  );
  assign _4_ = \u2.b ;
  assign _3_ = \u2.a ;
  assign \u2.y  = _5_;
  assign \u2.a  = net1;
  assign \u2.b  = c;
  assign y = \u2.y ;
  assign _1_ = \u1.b ;
  assign _0_ = \u1.a ;
  assign \u1.y  = _2_;
  assign \u1.a  = a;
  assign \u1.b  = b;
  assign net1 = \u1.y ;
endmodule
```
commnads given in yosys to flatten the netlist is as follows 
 
 **yosys> write_verilog -noattr multiple_modules_hier.v**
 
**Various Flop coding styles and optimization SKY130RTL D2SK3 L1 Why Flops and Flop coding styles part1**
why a flop:In combinational circuits output changes with respect to change in input ,for the change to occur at output there is a propagation delay(time taken by logical circuit to change its state) of gate.Due to this there may be chance of getting glitch at output.if there are multiple combinational circuits in the design chances of occuring glitches will be high.To avoid this we will use a flop,When a flop is used, the output of combinational circuit is stored in it and it is propagated only at the posedge or negedge of the clock so that the next combinational circuit gets a glitch free input thereby stabilising the output.
to initialize flops set and reset pins are avaialable,these can be synchronous or asynchronous
**LAB6-SKY130RTL D2SK3 L3 Lab flop synthesis simulations part1**
by using gtkwave simulator here is the simulation results for asyncronous d f/f
<img width="1440" alt="Screen Shot 2022-05-02 at 01 08 58" src="https://user-images.githubusercontent.com/104512677/166161963-f5c11f7b-41c1-4ef7-839e-af0aa097da63.png">
**SKY130RTL D3SK1 L3 Introduction to optimisations part3 Advanced State Optimisation**
In digital design we have two optimizations 
    			1.combinational logic optimization
			2.sequential optimization
			
In combinational optimization ,optimization is done  for the most optimized logic by
				1.constant propagation:by using this we can reduce the number of transistors which in turn reduces area,power
				<img width="1440" alt="Screen Shot 2022-05-02 at 01 34 24" src="https://user-images.githubusercontent.com/104512677/166162912-f74b3d0a-8d61-4e55-8b36-9f46767650b0.png">
				2.boolean logic optimization:In this we can reduce boolean equation to  a simpler one 
<img width="1440" alt="Screen Shot 2022-05-02 at 01 37 44" src="https://user-images.githubusercontent.com/104512677/166162962-7bebf7d3-23f6-4f33-a4e2-83d3cb171f97.png">

In sequential optimization we have sequential constant propagation
				   Advanced{cloning,retiming.state optimization}

**SKY130RTL D3SK2 L1 Lab06 Combinational Logic Optimisations part1**
files used for optimization 
<img width="1440" alt="Screen Shot 2022-05-02 at 01 59 46" src="https://user-images.githubusercontent.com/104512677/166163441-e90cfec5-bd0e-41cc-9f18-7525fea3b99f.png">

synthesizing opt_check in yosys<img width="1440" alt="Screen Shot 2022-05-02 at 02 05 51" src="https://user-images.githubusercontent.com/104512677/166163642-bd2dbf1d-8fbd-4d39-bf6c-59a23603621b.png">
the command used for constant optimization is 
       **opt_clean -purge **
 
 after linking the design by "show " command we got graphical representation as shown<img width="1440" alt="Screen Shot 2022-05-02 at 02 10 03" src="https://user-images.githubusercontent.com/104512677/166163846-a76413f4-d6a4-4a13-8284-67c4f106c288.png">
 example 1 opt_check
 ```
 module opt_check (input a , input b , output y); assign y = a?b:0; endmodule
 ```
 example 2 
 
```
module opt_check2 (input a , input b , output y); assign y = a?1:b; endmodule
```
example 3
```
module opt_check3 (input a , input b, input c , output y); assign y = a?(c?b:0):0; endmodule
 
```
**Lab07 Sequential Logic Optimisations part1**
example1 In the synthesis report, we'll see that a Dflop was inferred in this example
```
module dff_const1(input clk, input reset, output reg q); always @(posedge clk, posedge reset) begin if(reset) q <= 1'b0; else q <= 1'b1; end
       
```
example 2
```
module dff_const2(input clk, input reset, output reg q); always @(posedge clk, posedge reset) begin if(reset) q <= 1'b1; else q <= 1'b1; end

endmodule
```
**SKY130RTL D3SK3 L2 Lab07 Sequential Logic Optimisations part2**
example3

```
module dff_const3(input clk, input reset, output reg q); reg q1;

always @(posedge clk, posedge reset) begin if(reset) begin q <= 1'b1; q1 <= 1'b0; end else begin q1 <= 1'b1; q <= q1; end end

endmodule
```
example 4
```
module dff_const4(input clk, input reset, output reg q); reg q1;

always @(posedge clk, posedge reset) begin if(reset) begin q <= 1'b1; q1 <= 1'b1; end else begin q1 <= 1'b1; q <= q1; end end

endmodule
```
example 5
```
module dff_const5(input clk, input reset, output reg q); reg q1;

always @(posedge clk, posedge reset) begin if(reset) begin q <= 1'b0; q1 <= 1'b0; end else begin q1 <= 1'b1; q <= q1; end end

endmodule
```
**SKY130RTL D3SK4 L1 Seq optimisation unused outputs part1**
example 1
```
module counter_opt (input clk , input reset , output q); reg [2:0] count; assign q = count[0];

always @(posedge clk ,posedge reset) begin if(reset) count <= 3'b000; else count <= count + 1; end

endmodule
```

In this counter logic after synthesizing its showing only one flop shown in the snippet
<img width="1440" alt="Screen Shot 2022-05-02 at 02 51 28" src="https://user-images.githubusercontent.com/104512677/166165114-6a9225c1-8f4e-4da4-a351-ffad3d55fca3.png">

				   

				
		

 
 




















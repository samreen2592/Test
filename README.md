# Introduction
     __This report is a final submission of 5-day workshop from VLSI Sytem Design-IAT on RTL design and synthesis using open source tools,in particular iVerilog, GTKWave, Yosy and Skywater 130nm Standard Cell Libraries
     
## Introduction to RTLDesignandSynthesis
RTLDesign:Register transfer level is a mode of transfer of logic from register to register.RTLDesign can be one code orr set of codes that contain multiple modules for the realisation of logic 
Testbench:Testbench is the setup to apply stimulus test vectors to know how to check it Test bench does'nt have primary input or primary output<img width="763" alt="Screen Shot 2022-05-01 at 21 44 00" src="https://user-images.githubusercontent.com/104512677/166154676-5a0978be-00e3-4196-a5c9-a578a1551206.png">
Simulator:simulator works based on the change in input the output is evaluated .no change in input there will be no change in output.here is the flow of front end design 
<img width="800" alt="Screen Shot 2022-05-01 at 21 46 39" src="https://user-images.githubusercontent.com/104512677/166154789-bb8de989-e6a7-46f2-b3aa-8081ddca0f35.png">

gtkwavelab1:In this lab we are working on linux operating system by cloning the files from github using comman git clone
<img width="1440" alt="Screen Shot 2022-04-29 at 16 06 17" src="https://user-images.githubusercontent.com/104512677/166154933-133d368d-f97e-4cbc-a4fb-83edb7163a79.png">
<img width="1440" alt="Screen Shot 2022-04-29 at 16 08 38" src="https://user-images.githubusercontent.com/104512677/166155034-10aac897-add4-4389-a970-98fb14ad1032.png">

lab2:Introduction to iverilog and gtkwave In this lab simulation of multiplexer is done and VCD(Value Change Dump) file is generated by adding both verilog code and testbench to iverilog in the gtkwave waveforms are generated by using inputs in the testbench 
<img width="1440" alt="Screen Shot 2022-04-29 at 16 13 38" src="https://user-images.githubusercontent.com/104512677/166155491-c6ef3d2d-389f-40be-bb97-ac0e2f886d2f.png">


verilog code and testbench for multiplexer

**module good_mux(input i0,input i1,input sel,output y)
always @ (*)
if {sel}
y<=i1;
else
y<=i0;
end
endmodule**

**timescale 1ns/1ps
 module tb_good_mux"
//inputs 
i0,i1,sel:
//outputs
wire y;
// Instantiate the Unit Under Test (UUT), name based instantiation
good_mux uut (.sel(sel),.i0(i0),.i1(i1),.y(y));
//good_mux uut (sel,i0,i1,y); //order based instantiation
initial begin
$dumpfile("tb_good_mux.vcd");
$dumpvars(0,tb_good_mux);
// Initialize Inputs
sel = 0;
i0 = 0;
i1 = 0;
#300 $finish;
end
always #75 sel = ~sel;
always #10 i0 = ~i0;
always #55 i1 = ~i1;
endmodule**




